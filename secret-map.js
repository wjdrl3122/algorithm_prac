/*
네오는 평소 프로도가 비상금을 숨겨놓는 장소를 알려줄 비밀지도를 손에 넣었다. 그런데 이 비밀지도는 숫자로 암호화되어 있어 위치를 확인하기 위해서는 암호를 해독해야 한다. 다행히 지도 암호를 해독할 방법을 적어놓은 메모도 함께 발견했다.

지도는 한 변의 길이가 n인 정사각형 배열 형태로, 각 칸은 "공백"(" ") 또는 "벽"("#") 두 종류로 이루어져 있다.
전체 지도는 두 장의 지도를 겹쳐서 얻을 수 있다. 각각 "지도 1"과 "지도 2"라고 하자. 지도 1 또는 지도 2 중 어느 하나라도 벽인 부분은 전체 지도에서도 벽이다. 지도 1과 지도 2에서 모두 공백인 부분은 전체 지도에서도 공백이다.
"지도 1"과 "지도 2"는 각각 정수 배열로 암호화되어 있다.
암호화된 배열은 지도의 각 가로줄에서 벽 부분을 1, 공백 부분을 0으로 부호화했을 때 얻어지는 이진수에 해당하는 값의 배열이다.
*/

//--------------------------- 문제 ------------------------------------------------

/*

1. 비트 or 논리 연산자
비교하는 비트 중에서 하나라도 1이면 1을 반환한다.

2. 

*/

//--------------------------- 해결방안 ------------------------------------------------

let n = 6
let arr1 = [46, 33, 33 ,22, 31, 50]
let arr2 = [27 ,56, 19, 14, 14, 10]

function solution(n, arr1, arr2) {
  const answer = [];
  
  for (let i = 0; i < n; i++) {
    // 배열 1과 배열 2를 비트 or 연산자로 둘다 0이 아닌 숫자는 1로 반환 후 2진수로 변환한 문자를 반환
      const strLine = (arr1[i] | arr2[i]).toString(2)
    //반환된 문자를 조각내어 배열로 반환
      const arrLine = strLine.split("")
    //반환된 배열 길이가 n 보다 작으면 클때까지 반복
      while (arrLine.length < n) {
    //unshift 새로운 요소를 배열의 맨 앞쪽에 추가하고, 새로운 길이를 반환
          arrLine.unshift("0")
      } 
    // join은 배열 => 문자 로 만든다.
    // 1과 0 이 나열된 배열을 3항 연산자로 치환 후 join 으로 연결
      const decLine = (arrLine.map(i => i === "1" ? "#" : " ")).join("")

      answer.push(decLine)
  }
  return answer;
  }

solution(n, arr1, arr2)

//--------------------------- 코멘트 -----------------------------------

/*
비트연산자를 몰라서 고생했던 문제..

특정 텍스트를 비교 및 변환하려면 결국 쪼개야 값을 얻을 수 있다는것을 다시 한번 상기 시키는 문제

삽질했던 내용
- 다른 문자열들을 맞추기 위해 '+' 기호를 써서 맞췄다.
- 연산자를 몰라서 두 배열의 같은 순서의 요소를 찾아 텍스트를 비교하려 했지만 쉽지 않았다.

split -> map -> join 콤보는 알고있어도 막상 활용하기 어려웠는데 이번 문제로 많이 배웠다.

string 을 바꿔야 한다면 배열로 바꿔서 값을 수정하는 해당 문제를 꼭 기억하자.
*/

